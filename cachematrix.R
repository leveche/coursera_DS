
## makeCacheMatrix creates a list the elements of which are the data
## payload, as well as the setter and getter methods for data and the
## cached inverse.

## as an illustration:

## create a new 'smart' matrix:
## > m <- makeCacheMatrix()
## set its value to twice the 2x2 identity matrix:
## > m$set(rbind(c(2,0),c(0,2)))
## Retrieve the value
## > m$get()
##      [,1] [,2]
## [1,]    2    0
## [2,]    0    2

## In other words, the closure we have created has features similar to
## OOP environments: the elements of the returned list are the methods
## while the variables in the closure correspond to the 'fields' of an
## object.

makeCacheMatrix <- function(x = matrix()) {

    ## getter and setter methods are boilerplate

    get <- function() x
    set <- function(y) {
        ## assigns the value to the variables in the *parent* scope
        x   <<- y
        inv <<- NULL
    }

    # (cached) inverse
    inv <- NULL

    # methods to operate on the cached inverse
    # getter is trivial
    getinv <- function() inv
    # setter receives the value and assigns it to the inv variable in
    # the *parent* scope
    setinv <- function(matrixInverse) inv <<- matrixInverse
    
    # Return the list of methods
    list(set = set, get = get, setinv = setinv, getinv = getinv)

}


## cacheSolve operates on the closure generated by makeCacheMatrix it
## checks whether the matrix has inverse cached, and calculates one if
## it doesn't.

## A usage example:

## First-time calculation:
## > cacheSolve(m)
##      [,1] [,2]
## [1,]  0.5  0.0
## [2,]  0.0  0.5

## run it again to retrieve the cached version:
## > cacheSolve(m)
## getting cached data
##      [,1] [,2]
## [1,]  0.5  0.0
## [2,]  0.0  0.5

cacheSolve <- function(x, ...) {

    ## get the cached value for the inverse via the 'smart matrix'
    ## getter
    inv <- x$getinv()

    # since the matrix setter voids the cached value for the inverse
    # every time the matrix is updated, a non-null value means we can
    # simply return the cached value.

    if(!is.null(inv)) {
        message("getting cached data")
        return(inv)
    }

    ## Tough luck, no cached value to fall back on, need to calculate
    ## one here.
    
    # get the matrix (via the getter method)
    data <- x$get()

    # calculate the inverse
    inv <- solve(data, ...)

    # update the cache via the setter method
    x$setinv(inv)

    ## return the inverse matrix
    inv
}
